# 操作系统

* 并发(concurrency)
  * 单核 CPU 里的多线程，通常是有线程要处于等待状态(系统给每个线程分配时间片来执行)
* 并行(parallelism)
  * 如果想要多线程同时执行, 有两种方法: 多核 CPU 或者超线程技术(在同一时间里，应用程序可以使用芯片的不同部分, 超线程 CPU 在系统中也会被识别成两个 CPU)
  * 一般来说, 多线程要在多核上才能真正有优势

## 进程(process)

进程间不共用内存

## 线程(thread)

* `detach`: 将线程分离, 使得线程的执行可以单独在后台运行. 一旦线程执行完毕, 它所分配的资源将会被释放, 通常这种线程被称为守护线程.
* `join`: 被 join 的线程将阻塞调用者所在的线程直至被 join 的线程执行结束

## 协程

* coroutine, 是一个语言层面实现的东西, 和操作系统无关
* 在同一个线程中通过保存代码执行段状态, 进行代码段的分次执行, 以及多个代码段的交织执行. 每个代码段可以成为一个协程
* 根据保存当前 context 的方式可以分为有栈协程和无栈协程

## 悲观锁和乐观锁

悲观锁总是假设最坏的情况, 每次去拿数据的时候都认为别人会修改, 所以每次在拿数据的时候都会上锁, 这样别人想拿这个数据就会阻塞直到它拿到锁. 也就是**资源每次只给一个线程使用, 适用于多写场景**

乐观锁总是假设最好的情况, 每次去拿数据的时候都认为别人不会修改, 所以不会上锁, 但是在更新的时候会判断一下在此期间别人有没有去更新这个数据. **适用于多读场景**. 实现方式通常基于 CAS(compare and swap), 比较与交换, 如常用的版本号机制

## 自旋锁(spinlock)和互斥锁(mutex)

```javascript
// 自旋锁
while (抢锁(lock) == 没抢到) {
  不断重试, 因此会过多的占用 CPU 的时间
}
// 互斥锁
while (抢锁(lock) == 没抢到) {
  本线程先去睡了请在这把锁的状态发生改变时再唤醒
}
```

> [Linux 内核揭秘](https://xinqiu.gitbooks.io/linux-insides-cn/content/)