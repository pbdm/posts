# Web 内存

由于很容易被用户感知, 所以内存问题十分重要, 他主要分为以下三种

* 内存泄露(memory leak): 随着时间的延长使用的内存越来越多(无法回收)导致性能越来越差
* 内存膨胀(memory bloat): 内存占用过多导致页面性能一直很差
  * 比如长列表
    * [react-virtualized](https://github.com/bvaughn/react-virtualized)
    * [twitter](https://mobile.twitter.com/home)
* 频繁的垃圾回收(garbage collection)时的脚本暂停执行导致页面出现延迟或者经常暂停

## 内存垃圾回收

* 引用计数(有循环引用的问题)
* 标记清除: 不能被 GC roots 遍历到的对象都将被内存回收
  * GC roots 包括 Window, Global, DOM 树

## Task Manager(任务管理器)

打开 More tools > Task manager 可以看到一些基本的内存使用信息

![memory](https://raw.githubusercontent.com/pbdm/img/master/20170221143208_Vs5TPC_Screenshot.jpeg)

* Memory(Memory Footprint): 原生内存, 如果此值正在增大, 说明正在创建 DOM 节点
* JavaScript Memory: JS 堆(heap), 如果 live 数字在增大, 要么是正在创建新对象, 要么是现有对象正在增长

## Performance

~~旧版 Chrome 叫 Timeline~~

使用 Performance 调试的时候, 最好在开始和结束 recording 之前点击 Collect garbage 按钮来强制执行内存回收, 以便更好的观察内存泄露情况.

如果 JS 堆大小或节点大小不断增大, 则可能存在内存泄漏

<<< @/playground/memory/performance-grow.html

查看方式如下

![memory](https://raw.githubusercontent.com/pbdm/img/master/20170221152537_WdxCMR_Screenshot.jpeg)

## Heap Snapshots

### Summary 视图

#### 查看 detached DOM tree 内存泄露

detached 的定义:

* 不存在页面的 DOM tree 中
* 仍然有 javascript 逻辑引用(比如一些事件的绑定)

DOM node 想要被内存回收, 必须同时满足以下的条件:

* 不存在页面的 DOM tree 中
* 没有 javascript 逻辑引用

所以如果 DOM node 是 detached 的, 就会造成内存泄露

下面是一个产生 detached 的代码示例

<<< @/playground/memory/heap-detached.html

查看方式如下

![memory](https://raw.githubusercontent.com/pbdm/img/master/20170221171504_D1ICtM_Screenshot.jpeg)

* 老版本的显示有颜色高亮提示
  * 黄色: 存在 Javascript 的直接引用
  * 红色: 不存在 Javascript 的直接引用
* Shallow Size(浅层大小): 该对象直接占用内存
* Retained Size(保留大小): 该对象直接占用内存(Shallow Size) + 该对象引用的对象所占用的内存, 当该对象被删除后, GC roots 就无法遍历到这部分内存了
* `@` 字符后面的数字是对象的唯一 ID

### Comparison 视图

通过相互比较多个快照，查找泄漏的对象

### Containment 视图

应用的对象结构的“俯瞰视图”

## Allocation instrumentation on timeline

~~旧版 Chrome 叫 Allocation Timelines~~

定期(50ms)拍摄 Heap Snapshots, 可以从时间线的角度查看内存的使用情况

蓝色竖线表示在时间线最后对象仍然存活

灰色竖线表示对象已在时间线期间分配，但曾对其进行过垃圾回收(因此不会再下面的面板出现?)

<<< @/playground/memory/timeline-grow.html

查看方式如下

![memory](https://raw.githubusercontent.com/pbdm/img/master/20170222092032_lNAh7a_Screenshot.jpeg)

## Allocation sampling

~~旧版 Chrome 叫 Allocation Profile~~

可以从函数调用栈的角度来查看内存使用情况
![memory](https://raw.githubusercontent.com/pbdm/img/master/20170222092633_m0jsDG_Screenshot.jpeg)

## 常见内存泄露原因

### 意外的全局变量

```javascript
function foo(arg) {
  // 如果不在严格模式下, bar 就永远变成了全局变量
  bar = "some text";
}
```

### 未销毁的定时器和回调

```javascript
var someResource = getData();
setInterval(function() {
  // 就算 node 元素被移除了, 整个定时器依然无法回收内存
  var node = document.getElementById('Node');
  if(node) {
    node.innerHTML = someResource;
  }
}, 1000);
```

### DOM 引用

```javascript
var elements = {
  image: document.getElementById('image')
};
function doStuff() {
  elements.image.src = 'http://example.com/image_name.png';
}
function removeImage() {
  document.body.removeChild(document.getElementById('image'));
  // 这个时候我们对于 #image 仍然有一个引用, Image 元素, 仍然无法被内存回收.
}
```

### closure: 闭包(因为其有权访问外部函数的变量)

> [An interesting kind of JavaScript memory leak by meteor](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156)

## 图片占用内存算法

大概是这样的吧, 只能做个参考...

RAM = 图宽 × 图高 × 4

分辨率为200的图片：200 × 200 × 4 = 160KB

> [内存管理 in MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)
>
> [Fix Memory Problems | Web | Google Developers(有些旧了, 里面 chrome 的界面都已经变了)](https://developers.google.com/web/tools/chrome-devtools/memory-problems/)
>
> [译】JS 中的内存管理 && 常见的 4 种内存泄露处理方式](http://elevenbeans.github.io/2017/10/13/js-memory-management/)
>
> [精读《JS 中的内存管理》](https://zhuanlan.zhihu.com/p/30552148?group_id=908267248675049472)
>
> [4类 JavaScript 内存泄漏及如何避免 by Alon's Blog](http://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/)
>
> [barretlee](http://www.barretlee.com/blog/2016/05/30/h5-crash-research/)