# JS 数据类型和数据结构

> [JS 数据类型和数据结构 in MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures)

* 可以使用 [typeof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof) 返回数据类型
  * 除了返回数据类型, (除了 null), 还可以返回 function
    * **由于历史原因, `typeof null === 'object'`**
* 可以通过 `Object.prototype.toString.call(value)` 来判断对象类型
  * 返回 "[object type]", 其中 type 是对象的类型

## 原始类型(primitive)

* Boolean: true, false
  * ~~在变量前面加`!!` 可以强制转换boolean~~(感觉这个在语义理解上并不可取)
* Null: null
* Undefined: undefined
* Number: 基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(2^53 -1) 到 2^53 -1) 以及 Infinity, NaN(Not-a-Number)
  * [isNaN() 函数用来确定一个值是否为NaN(不是一个数字)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN)
* BigInt: ES10(2019) 新增, 表示任意精度格式的整数, 可以超过 `Number.MAX_SAFE_INTEGER`
  * 要创建一个 BigInt，将 n 作为后缀添加到任何整数文字字面量。例如，123 变成 123n
* String
* Symbol: ES6(2015) 新增, 唯一的并且是不可修改

## Object

* [What does the built in object hierarchy look like in javascript?](https://stackoverflow.com/questions/19891453/what-does-the-built-in-object-hierarchy-look-like-in-javascript)

![js object hierarchy](https://yuml.me/b2af19c6.png)

* `Object.freeze()`: 冻结一个对象(不只更改了writable)
  * `Object.seal()`: 对比`freeze` 只冻结首层, 密封的对象然然可以改变它们现有的属性

### 数据属性 vs 访问器属性

```javascript
// 数据属性
Object.defineProperty(person, 'name', {
  configurable: true, //能否通过 delete 删除属性或者修改属性, 能否将属性修改为访问器属性
  enumerable: true, // 能否通过 for in,  Object.keys 循环返回属性
  writable: true, // 是否能更改属性的值
  value: 'Nicholas' // 默认为undefined
})

// 访问器属性
Object.defineProperty(book, 'year', {
  configurable: true, //能否通过delete删除属性或者修改属性, 能否将属性修改为访问器属性
  enumerable: true, // 能否通过 for in, Object.keys 循环返回属性
  // 在读取属性时调用的函数
  get: function() {
    return this._year;
  },
  // 在写入属性时调用的函数
  set: function(newValue) {
    if (newValue > 2004) {
      this._year = newValue;
      this.edition += newValue - 2004;
    }
  }
})
```

* `Object.getOwnPropertyDescriptor(obj, 'key')`:  获取置顶对象上一个自有属性对应的属性描述符

* [所有的标准的内置对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects)

### 基本对象

* Object
* Function
  * [IIFE(immediately-invoked-function-expression)](http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife)
* Boolean
* Symbol
* Error
  * 以及一些其他的 Error

### 数字和日期

* [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)
* Number
* BigInt
* Math

### 字符串

* String
* RegExp

### 可索引的集合对象(有序集)

* Array
  * change nodeList to array: `[...document.querySelectorAll('a')]`
  * [`new Array()` 和 `Array()`是一样的](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.1)
* 类型数组(二进制数组, TypedArray)
  * 有以下两个主要概念
    * `ArrayBuffer`: 用来表示通用的、固定长度的原始二进制数据缓冲区
    * `DataView`: 一个可以从 ArrayBuffer 对象中读写多种数值类型的底层接口
  > [typed array in MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays)

### 键控集(Keyed collections, 使用键的集合对象)

* Map
  * 类似 Object
  * 保存键值对
  * [与 Object 区别](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map#Objects_%E5%92%8C_maps_%E7%9A%84%E6%AF%94%E8%BE%83)
    * Object 的键只能是字符串或者 Symbols, 但 Map 的键可以是任意值, 包括函数, 对象, 基本类型
    * Object 不可迭代, Map 可以迭代
    * Map 在涉及频繁增删键值对的场景下会比纯对象有些性能优势
  * 如何决定用 Objcet 还是 Map
    * 如果键在运行时才能知道, 或者所有的键类型相同, 所有的值类型相同, 那就使用Map。
    * 如果需要将原始值存储为键, 则使用Map, 因为Object将每个键视为字符串, 不管它是一个数字值、布尔值还是任何其他原始值
    * 如果需要对个别元素进行操作, 使用Object
* WeakMap
  * 键是弱引用的 Map
* Set
  * 类似 Array, 相当于值不重复的数组
  * Set 无法使用 `Array.prorotype.map`, 因为 没有 `length` 属性(有 size)
* WeakSet
  * WeakSet 对象中只能存放对象引用, 不能存放值, 而 Set 对象都可以
  * WeakSet 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素

### 其他

* JSON
  * parse
  * stringify
* Promise
* Reflect
* [Proxy](2018-03-23-js-proxy.md)
* etc...
