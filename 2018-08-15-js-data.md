# JS 数据类型和数据结构

## 基本类型

* 原始类型(primitive type), 值类型
  * Undefined: undefined
  * Null: null
  * Boolean: true, false
    * ~~在变量前面加`!!` 可以强制转换 Boolean~~(感觉这个在语义理解上并不可取)
  * Number: 基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(2^53 -1) 到 2^53 -1) 以及 Infinity, NaN(Not-a-Number)
    * 存在 0 和 -0, 1/0 === Infinity, 1/-0 === -Infinity
    * 通过 [Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON) 解决精度丢失问题
    * [isNaN() 函数用来确定一个值是否为NaN(不是一个数字)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN)
  * BigInt: ES10(2019) 新增, 表示任意精度格式的整数, 可以超过 `Number.MAX_SAFE_INTEGER`
    * 要创建一个 BigInt，将 n 作为后缀添加到任何整数文字字面量。例如，123 变成 123n
  * String
  * Symbol: ES6(2015) 新增, 唯一的并且是不可修改
* Object: 对象, 引用类型

## 类型判断

* 使用 [typeof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof) 返回数据类型
  * 除了返回数据类型(除了 null), 还可以返回 function
    * **由于历史原因, `typeof null === 'object'`**
* 通过 `Object.prototype.toString.call(value)` 来判断
  * 返回装箱内置对象的私有的 Class 属性 `[object type]`, 其中 type 是对象的类型, 但是这个类型可以通过修改 `Symbol.toStringTag` 改变...

```javascript
  Object.prototype.toString.call(Object('a')) //[object String]
  // 可通过  `Symbol.toStringTag 定义`
  var o = { [Symbol.toStringTag]: "MyObject" }
  Object.prototype.toString.call(o) // [object MyObject]
```

## 标准内置对象

* [所有的标准的内置对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects)
* [What does the built in object hierarchy look like in javascript?](https://stackoverflow.com/questions/19891453/what-does-the-built-in-object-hierarchy-look-like-in-javascript)

![js object hierarchy](https://yuml.me/b2af19c6.png)

### 基本类型对应的对象

#### Object

* Object

#### 原始类型对应的对象

* Boolean
* String
* Number
* Symbol
* BigInt

直接调用以上 5 个函数, 均可以进行类型转换(一个拆箱的过程)

直接用 new 调用 Number, String 和 Boolean 时, 它们产生对象.

直接用 new 调用 Symbol, BigInt 会抛出错误.

#### 装箱与拆箱

* 装箱转换: 原始类型 -> 对象类型
  * 常用于原始类型调用对应的对象类型方法时, 比如 `"abc".charAt(0)` 会根据原始类型构造一个临时对象(这样就可以对原始类型使用一堆方法了)
  * 内置的 Object 函数可以在 JavaScript 代码中显式调用装箱能力, 比如 `Object(Symbol("a"))`
  * `Function.prototype.call` 可以强迫产生装箱, 比如 `(function(){ return this; }).call(Symbol("a"))`
* 拆箱转换: 对象类型 -> 原始类型
  * 如进行 `Number(xxx), String(xxx)` 等强制类型转换时
  * 对象到 String 和 Number 的转换都遵循先拆箱再转换的规则. 通过拆箱转换, 把对象变成基本类型, 再从基本类型转换为对应的 String 或者 Number
  * 拆箱过程如下
    * 尝试调用 `[Symbol.toPrimitive]`(ES6之后)
    * 尝试调用`valueOf` 和 `toString`(调用顺序与类型有关)
      * Object.prototype.valueOf(): 返回指定对象的原始值
      * Object.prototype.toString(): 当该对象被表示为一个文本值时, 或者一个对象以预期的字符串方式引用时自动调用. 默认情况下, toString() 方法被每个 Object 对象继承. 如果此方法在自定义对象中未被覆盖, toString() 返回 "[object type]"(可用于类型判断)
    * 如果方法都不存在或者没有返回原始类型, 则会产生类型错误 TypeError.

### 基本对象

* [Function](2019-12-11-js-function.md)
* Error
  * 以及一些其他的 Error

### 基础功能

* [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)
* Math
* RegExp

### 可索引的集合对象(有序集)

* Array
  * change nodeList to array: `[...document.querySelectorAll('a')]`
  * [`new Array()` 和 `Array()`是一样的](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.1)
* 类型数组(二进制数组, TypedArray)
  * 有以下两个主要概念
    * `ArrayBuffer`: 用来表示通用的、固定长度的原始二进制数据缓冲区
    * `DataView`: 一个可以从 ArrayBuffer 对象中读写多种数值类型的底层接口
  > [Typed Arrays in MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays)

### 键控集(Keyed collections, 使用键的集合对象)

* Map
  * 类似 Object
  * 保存键值对
  * [与 Object 区别](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map#Objects_%E5%92%8C_maps_%E7%9A%84%E6%AF%94%E8%BE%83)
    * Map 中的键值是有序的(按照插入顺序)
    * Object 不可迭代, Map 可以迭代
    * Object 的键只能是字符串或者 Symbols, 但 Map 的键可以是任意值, 包括函数, 对象, 基本类型
  * 如何决定用 Objcet 还是 Map
    * 如果只是构造一个简单的 key -> value 结构, Object 就可以了
    * 如果需要在对象内通过使用函数操作别的 key, 只能使用 Object
    * 如果需要和 JSON 互相转换, 只能使用 Object
    * **Map 在涉及频繁增删键值对的场景下会比 Object 有些性能优势**
* WeakMap
  * 键是弱引用的 Map(在没有其他引用存在时垃圾回收能正确进行)
* Set
  * 类似 Array, 相当于值不重复的数组
  * Set 无法使用 `Array.prorotype.map`, 因为 没有 `length` 属性(有 size)
* WeakSet
  * WeakSet 对象中只能存放对象引用, 不能存放值, 而 Set 对象都可以
  * WeakSet 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素

### 其他

* JSON
  * parse
  * stringify
* Promise
* Reflect
* [Proxy](2018-03-23-js-proxy.md)
* etc...

## 数据属性 vs 访问器属性

```javascript
// 数据属性
Object.defineProperty(obj, 'key', {
  configurable: true, //能否通过 delete 删除属性或者修改属性, 能否将属性修改为访问器属性
  enumerable: true, // 能否通过 for in,  Object.keys 循环返回属性
  writable: true, // 是否能更改属性的值
  value: 'Nicholas' // 默认为undefined
})

// 访问器属性
Object.defineProperty(obj, 'key', {
  configurable: true, //能否通过 delete 删除属性或者修改属性, 能否将属性修改为数据属性
  enumerable: true, // 能否通过 for in, Object.keys 循环返回属性
  // 在读取属性时调用的函数
  get: function() {
    return this._year;
  },
  // 在写入属性时调用的函数
  set: function(newValue) {
    if (newValue > 2004) {
      this._year = newValue;
      this.edition += newValue - 2004;
    }
  }
})
```

通常定义属性时默认产生所有值都为 true 的数据属性

* `Object.getOwnPropertyDescriptor(obj, 'key')`: 获取置顶对象上一个自有属性对应的属性描述符
* `Object.getOwnPropertyNames(obj)` 获取置顶对象所有自身属性的名称数组
  * `Object.keys(obj)` 只能获取可枚举的属性
* `Object.freeze()`: 冻结一个对象(不只更改了writable)
* `Object.seal()`: 对比`freeze` 只冻结首层, 密封的对象可以改变它们现有的属性

> [JS 数据类型和数据结构 in MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures)
